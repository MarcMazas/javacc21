/*
 * This is a a second pass at an implementation of the preprocessor 
 * for C#. I had originally thought that I could just create a 
 * generic preprocessor and use it for both internal development 
 * and for C# itself but that turned out not to bethe case. For one thing,
 * it appears that internal JavaCC development will require some extra 
 * features not in C#. But also, the  way the preprocessing works in C#
 * is extremely bizarre and screwy, almost certainly because they wrote
 * a spec based on the initial implementation, rather than the other way round!
 * For one thing, a totally correct C# preprocessor has to be "aware" of 
 * strings and multiline comments in the source. The current implementation
 * is about 99.97% correct. There are a couple of corner cases I 
 * am aware of, but will get to them later.
 */

DEFAULT_LEXICAL_STATE=CSHARP;
TREE_BUILDING_ENABLED=false;
ENSURE_FINAL_EOL;
MINIMAL_TOKEN;
TABS_TO_SPACES=4;

PARSER_PACKAGE=org.parsers.csharp.cspreprocessor;
PARSER_CLASS=Preprocessor;

INCLUDE "CSharpLexer.javacc"

INJECT LEXER_CLASS : 
{
  boolean currentlyOn = true;
  final BitSet inactiveLines = new BitSet();

  private Token TOKEN_HOOK(Token token) {
    TokenType type = token.getType();
    if (type == EOF || this.lexicalState == LexicalState.PP_DIRECTIVE) return token;
    if (type == PP_EOL) {
      inactiveLines.set(token.getBeginLine());
      return token;
    }
    if (type == EOF || this.lexicalState == LexicalState.PP_DIRECTIVE) return token;
    if (content.charAt(token.getBeginOffset()) != '#' || !startsLine(token)) {
      if (!currentlyOn) inactivateLines(token);
      token.setUnparsed(true);
      return token;
    }
    inactiveLines.set(token.getBeginLine());
    return token;
  }

  void inactivateLines(Token tok) {
    inactiveLines.set(tok.getBeginLine(), tok.getEndLine()+1);
  }

  private boolean startsLine(Token tok) {
    for (int i = tok.getBeginOffset()-1; i >=0; i--) {
      char ch = content.charAt(i);
      if (ch == '\n') return true;
      if (!Character.isWhitespace(ch)) return false;
    }
    return true;
  }
}

INJECT PARSER_CLASS : 
   import java.util.Set;
   import java.util.HashSet;
{
    private final Set<String> definedSymbols = new HashSet<>();

    public PARSER_CLASS(Path path, Set<String> definedSymbols) throws IOException {
        this(path);
        if (definedSymbols !=null) addSymbols(definedSymbols);
    }

    public PARSER_CLASS(CharSequence content, Set<String> definedSymbols) throws IOException {
       this(content);
       if (definedSymbols != null) addSymbols(definedSymbols);
    }

    private void setLineMarker() {
        int start = lastConsumedToken.getBeginLine();
        int end = lastConsumedToken.getEndLine();
        if (isCurrentlyOn()) lineMarkers.set(start, end+1);
    }

    public void unsetSymbol(String symbol) {
        definedSymbols.remove(symbol);
    }

    public void addSymbols(Set<String> symbols) {
        definedSymbols.addAll(symbols);
    }

    public void setCurrentlyOn(boolean currentlyOn) {
      token_source.currentlyOn = currentlyOn;
    }

    public boolean isCurrentlyOn() {
      return token_source.currentlyOn;
    }
}

TOKEN : 
 <PP_DEFINE : <PP_START> "define"> : PP_DIRECTIVE
 |
 <PP_UNDEF : <PP_START> "undef"> : PP_DIRECTIVE
 |
 <PP_IF : <PP_START> "if" > : PP_DIRECTIVE
 |
 <PP_ELIF : <PP_START> "elif" > : PP_DIRECTIVE
 |
 <PP_ELSE : <PP_START> "else"> : PP_DIRECTIVE
 |
 <PP_ENDIF : <PP_START> "endif"> : PP_DIRECTIVE
 |
 <#PP_START : "#" (<PP_WS>)*>
 |
 <#PP_WS : [" ", "\t", "\f",
         "\u000b", "\u00a0", "\u1680",
         "\u2000"-"\u200a",
         "\u202f", "\u205f", "\u3000","\uC2A0"]>
;

UNPARSED : 
// The preprocessor lets any stray character through
// So we deal with invalid stuff on the next level.
  <ANY_CHAR : ~["\n"]>
  |
  <PP_IGNORED_DIRECTIVE : 
     <PP_START> 
// Just ignore all these for now.     
     ("pragma" | "line" | "warning" | "error" | "region" | "endregion" | "nullable")
     (~["\n", "\r"])* ("\r" | "\n" | "\r\n") 
  > 
; 
 
<PP_DIRECTIVE> UNPARSED :
  < EOL_COMMENT : "//" (~["\n"])* > 
;

<PP_DIRECTIVE> TOKEN : 
    <PP_TRUE : "true">
    |
    <PP_FALSE : "false">
    |
    <PP_SYMBOL : <CSHARP_IDENTIFIER_START> (<CSHARP_IDENTIFIER_PART>)* >
    |
    <PP_OR : "||">
    |
    <PP_AND : "&&">
    |
    <PP_LPAREN : "(">
    |
    <PP_RPAREN : ")">
    |
    <PP_ASSIGN : "=">
    |
    <PP_EQUALS : "==">
    |
    <PP_NOT_EQUALS : "!=">
    |
    <PP_NOT : "!"> 
    |
    <PP_EOL : "\n"> : CSHARP
;

<PP_DIRECTIVE> SKIP : < Whitespace: (<PP_WS>)+> ;

BitSet PP_Root#void : PP_Block <EOF> {return token_source.inactiveLines;};

PP_Block#void : (PP_IfBlock | PP_DefStatement | PP_UndefStatement)* ;

PP_IfBlock#void :
   {
      boolean alreadyHandled = false, result;
      final boolean previouslyOn = isCurrentlyOn();
   }
    <PP_IF>
    result = PP_Expression 
    <PP_EOL> 
    {
        if (result) alreadyHandled = true;
        setCurrentlyOn(result && previouslyOn);
    }
    PP_Block 
    (
        <PP_ELIF> result=PP_Expression <PP_EOL>
        {
            if (alreadyHandled) setCurrentlyOn(false);
            else {
                alreadyHandled = result;
                setCurrentlyOn(previouslyOn && result);
            } 
        }
        PP_Block
    )* 
    [
        <PP_ELSE>
        <PP_EOL>
        {setCurrentlyOn(!alreadyHandled && previouslyOn);}
        PP_Block
    ]
    <PP_ENDIF><PP_EOL>
    {setCurrentlyOn(previouslyOn);}
;

PP_DefStatement#void :
{
    String value = "1";
}
  <PP_DEFINE><PP_SYMBOL><PP_EOL>
  {
    if (isCurrentlyOn()) {
      definedSymbols.add(getToken(-1).getImage());
    }
  }
  
;

PP_UndefStatement#void : 
    <PP_UNDEF><PP_SYMBOL><PP_EOL>
    {if (isCurrentlyOn()) definedSymbols.remove(getToken(-1).getImage());}
;    

boolean PP_Expression#void :
  {
    boolean result, result2;
    boolean inequality = false;
  }
  result=PP_OrExpression
  [
    (<PP_EQUALS>|<PP_NOT_EQUALS>{inequality=true;}) 
    result2=PP_OrExpression 
    {
      result = inequality ? result != result2 : result == result2;
    }
  ]
  {return result;}
;

boolean PP_OrExpression#void :
  { boolean result, result2; }
   result=PP_AndExpression 
  (
    <PP_OR> 
    result2 = PP_AndExpression 
    {result = result || result2; }
  )*
  {return result;}
;

boolean PP_AndExpression#void :
  { boolean result, result2; }
    result=PP_NotExpression 
    (
      <PP_AND> 
      result2 = PP_NotExpression 
      { result = result && result2; }
    )*
   {return result;}
;   

boolean PP_NotExpression#void :
  { boolean not = false, result; }
   (<PP_NOT> {not = !not;})* 
   result=PP_PrimaryExpression 
  { return not ? !result : result; }
;

boolean PP_Parentheses#void :
   { boolean result; }
   <PP_LPAREN> 
   result=PP_Expression 
   <PP_RPAREN> 
   {return result;}
;

boolean PP_PrimaryExpression#void :
    { boolean result = false; }
    (
      result=PP_Parentheses
      |
      <PP_SYMBOL> {result = definedSymbols.contains(lastConsumedToken.getImage());}
      |
      <PP_TRUE> { result = true; }
      |
      <PP_FALSE> { result = false; }
    )
    {return result;}
; 
