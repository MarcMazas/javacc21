DEFAULT_LEXICAL_STATE=CSHARP;
PARSER_PACKAGE=org.parsers.csharplexer;

SKIP :
  <WHITESPACE : (<WS_CHAR>)+> #Whitespace
  |
  <#WS_CHAR : 
       [
         " ", "\t", "\n", "\r", 
         "\u000b", "\u00a0", "\u1680",
         "\u2000"-"\u200a",
         "\u202f", "\u205f", "\u3000"
       ]
  >
;

UNPARSED #Comment :
  < MULTI_LINE_COMMENT : "/*" (~["*"])* "*" (~["*","/"] (~["*"])* "*" | "*")* "/">
  |
  < SINGLE_LINE_COMMENT : "//" (~["\n"])* "\n" > 
;

TOKEN #Literal :
  < INTEGER_LITERAL: (<DECIMAL_LITERAL> | <HEX_LITERAL> | <BINARY_LITERAL>) (<INTEGER_TYPE_SUFFIX>)?> #IntegerLiteral
  |
  < REAL_LITERAL:
     ((<DECIMAL_LITERAL>)? ".")? <DECIMAL_LITERAL> (<EXPONENT_PART>)? (["f","F","d","D","m","M"])?
  > #RealLiteral
  |
  < #DECIMAL_LITERAL: ["0"-"9"]((["0"-"9","_"])*["0"-"9"])?>
  |
  < #HEX_LITERAL: "0" ["x","X"] <HEX_DIGITS>>
  |
  < #BINARY_LITERAL : "0b" (["0", "1", "_"])+ (["0","1"])?>
  | 
  < #INTEGER_TYPE_SUFFIX : "U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul"| "LU" | "Lu" | "lU" | "lu">
  |
  < #HEX_DIGITS: (["0"-"9","a"-"f","A"-"F","_"])* ["0"-"9","a"-"f","A"-"F"] >
  |
  < #EXPONENT_PART : ["e","E"] (["+","-"])? <DECIMAL_LITERAL> >
  |
  < FALSE : "false" > #BooleanLiteral
  |
  < TRUE : "true"> #BooleanLiteral
  | 
  < NULL : "null" > #NullLiteral
;

TOKEN #Delimiter :
  < LPAREN: "(" > 
| < RPAREN: ")" >
//| < LBRACE: "{" > 
| < RBRACE: "}" > 
| < LBRACKET: "[" > 
| < RBRACKET: "]" > 
| < SEMICOLON: ";" > 
| < COMMA: "," > 
;

TOKEN #Operator : 
 < GT: ">" > 
| < LT: "<" > 
| < BANG: "!" > 
| < TILDE: "~" > 
| < HOOK: "?" >
// The following two since 8.0
| < DOUBLE_HOOK: "??">
| < DOUBLE_HOOK_EQUALS : "??=">
| < COLON: ":" > 
| < EQ: "==" > 
| < LE: "<=" > 
| < GE: ">=" > 
| < NE: "!=" > 
| < SC_OR: "||" > 
| < SC_AND: "&&" > 
| < INCR: "++" > 
| < DECR: "--" > 
| < PLUS: "+" > 
| < MINUS: "-" > 
| < STAR: "*" > 
| < SLASH: "/" > 
| < BIT_AND: "&" > 
| < BIT_OR: "|" > 
| < HAT: "^" > 
| < REM: "%" > 
| < LSHIFT: "<<" > 
| < PLUSASSIGN: "+=" > 
| < MINUSASSIGN: "-=" > 
| < STARASSIGN: "*=" > 
| < SLASHASSIGN: "/=" > 
| < ANDASSIGN: "&=" > 
| < ORASSIGN: "|=" > 
| < XORASSIGN: "^=" > 
| < REMASSIGN: "%=" > 
| < LEFT_SHIFT_ASSIGN: "<<=" > 
| < RIGHT_SHIFT: ">>" > 
| < RIGHT_SHIFT_ASSIGN: ">>=" > 
| < ARROW : "=>"> 
| < ASSIGN: "=" > 
| < DOUBLE_COLON: "::" > 
| < DOT: "." > 
| < RANGE : ".." > 
| < VAR_ARGS: "..." > 
| < AT : "@"> 
;

// C# Keywords

TOKEN #KeyWord : 
   <ABSTRACT : "abstract" > 
   | < AS : "as" > 
   | < BASE : "base" > 
   | < BOOL : "bool" > 
   | < BREAK : "break" >
   | < BYTE : "byte" > 
   |  <CASE : "case" > 
   | < CATCH : "catch" > 
   | < CHAR : "char" > 
   | < CHECKED : "checked" > 
   | < CLASS : "class" > 
   | < CONST : "const" > 
   | < CONTINUE : "continue" > 
   | < DECIMAL : "decimal" > 
   | < DEFAULT : "default" > 
   | < DELEGATE : "delegate" > 
   | < DO : "do" > 
   | < DOUBLE : "double" > 
   | < ELSE : "else" > 
   | < ENUM : "enum" > 
   | < EVENT : "event" > 
   | < EXPLICIT : "explicit" > 
   | < EXTERN : "extern" > 
   | < FINALLY : "finally" > 
   | < FIXED : "fixed" > 
   | < FLOAT : "float" > 
   | < FOR : "for" > 
   | < FOREACH : "foreach" > 
   | < GOTO : "goto" > 
   | < IF : "if" > 
   | < IMPLICIT : "implicit" > 
   | < IN : "in" > 
   | < INT : "int" > 
   | < INTERFACE : "interface" > 
   | < INTERNAL : "internal" > 
   | < IS : "is">
   | < LOCK : "lock" >
   | < LONG : "long" >
   | < NAMESPACE : "namespace" >
   | < NEW : "new" >
   | < OBJECT : "object" >
   | < OPERATOR : "operator" >
   | < OUT : "out" >
   | < OVERRIDE : "override" >
   | < PARAMS : "params">
   | < PRIVATE : "private" > 
   | < PROTECTED : "protected" > 
   | < PUBLIC : "public" > 
   | < READONLY : "readonly" > 
   | < REF : "ref" > 
   | < RETURN : "return" > 
   | < SBYTE : "sbyte" > 
   | < SEALED : "sealed" > 
   | < SHORT : "short" > 
   | < SIZEOF : "sizeof" > 
   | < STACKALLOC : "stackalloc" > 
   | < STATIC : "static" > 
   | < STRING : "string" > 
   | < STRUCT : "struct" > 
   | < SWITCH : "switch" > 
   | < THIS : "this" > 
   | < THROW : "throw" > 
   | < TRY : "try" >
   | < TYPEOF : "typeof" >
   | < UINT : "uint" >
   | < ULONG : "ulong" >
   | < UNCHECKED : "unchecked" >
   | < UNSAFE : "unsafe" >
   | < USHORT : "ushort" > 
   | < USING : "using" > 
   | < VIRTUAL : "virtual" > 
   | < VOID : "void" >
   | < VOLATILE : "volatile" > 
   | < WHILE : "while" > 
// Now contextual Keywords
   | < __ARGLIST : "arglist">
   | < ADD : "add">
   | < ASSEMBLY : "assembly">
   | < ASYNC : "async" >
   | < AWAIT : "await" >
   | < GET : "get" >
   | < INIT : "init" >
   | < MODULE : "module">
   | < PARTIAL : "partial">
   | < RECORD : "record" >
   | < REMOVE : "remove">
   | < SET : "set" >
   | < VAR : "var" > 
   | < WHEN : "when">
   | < YIELD : "yield" >
   | < AND : "and">
   | < OR  : "or" >
   | < NOT : "not">
   | < WITH : "with" >
// Here are the soft keywords used in queries 
   | <ASCENDING : "ascending">
   | <BY : "by">
   | <DESCENDING : "descending">
   | <EQUALS : "equals">
   | <FROM : "from">
   | <GROUP : "group">
   | <INTO : "into">
   | <JOIN : "join">
   | <LET : "let">
   | <ON : "on">
   | <ORDERBY : "orderby" >
   | <SELECT : "select">
   | <WHERE : "where">  
;

INCLUDE "CSharpIdentifierDef.javacc"

TOKEN :
  <IDENTIFIER : ("@")? (<CSHARP_IDENTIFIER_START>|<UNICODE_ESCAPE>) (<CSHARP_IDENTIFIER_PART>|<UNICODE_ESCAPE>)*>
  |   
  <#UNICODE_ESCAPE : "\\" 
                    (
                      "u" (["0"-"9", "a"-"f", "A"-"F"]){4}
                      |
                      "U" (["0"-"9", "a"-"f", "A"-"F"]){8}
                    ) >
;

TOKEN #Literal :
  < CHARACTER_LITERAL: "'" ((~["'","\\","\n","\r"]) | <ESCAPED_CHAR>) "'"> #CharacterLiteral
  |
  < #ESCAPED_CHAR :  "\\"
                    (
                      (["0","a","b","f","n", "r","t","v","\\","'","\""])
                      |
                      "x" (["0"-"9", "a"-"f", "A"-"F"]){1,4}
                      |
                      "u" (["0"-"9", "a"-"f", "A"-"F"]){4}
                    ) 
  >
  |                                                  
  < #ESCAPED_CHAR2 :  "\\"
                    (
                      (["0","a","b","f","n", "r","t","v","\\","'","\""])
                      |
                      "x" (["0"-"9", "a"-"f", "A"-"F"]){1,4}
                      |
                      "u" (["0"-"9", "a"-"f", "A"-"F"]){4}
                      |
                      "U" (["0"-"9", "a"-"f", "A"-"F"]){8}
                    ) 
  >                                                  
  |
  < STRING_LITERAL: <REGULAR_STRING_LITERAL>| "@"<RAW_STRING_>> #StringLiteral
  |
  < #REGULAR_STRING_LITERAL : "\"" ((~["\"","\\","\n","\r"]) | <ESCAPED_CHAR2>)*  "\"">
  |
  < #RAW_STRING_ : "\"" (~["\""] | "\"\"")* "\"" > 
  | 
  < REGULAR_INTERPOLATION_START : "$\"" >  
  |
  < MULTI_INTERPOLATION_START : "$@\"" | "@$\"" > 
; 

<IN_REGULAR_INTERPOLATION>
TOKEN :
  // Just any non-interpolated character in an interpolated string.
  < NON_INTERPOLATED_TEXT : ((~["\"","\\","\n","\r","{","}"]) | "{{" | "}}" | <ESCAPED_CHAR2>)+ >
;

<IN_MULTI_INTERPOLATION>
TOKEN :
  // Just any non-interpolated character in an interpolated string.
  < NON_INTERPOLATED_TEXT2 : ((~["\"","{","}"] | "\"\"") | "{{" | "}}")+ >
;

<CSHARP, IN_REGULAR_INTERPOLATION, IN_MULTI_INTERPOLATION > 
TOKEN #Delimiter :
   <LBRACE : "{" >  
;

<IN_REGULAR_INTERPOLATION,IN_MULTI_INTERPOLATION >
TOKEN :
  < ENDING_QUOTE : "\"" >  
;  