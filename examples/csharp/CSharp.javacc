CSHARP_UNICODE_ESCAPE;
PARSER_PACKAGE="org.parsers.csharp";
NODE_PACKAGE="org.parsers.csharp.tree";
DEFAULT_LEXICAL_STATE=CSHARP;
ENSURE_FINAL_EOL;

INCLUDE "CSharpLexer.javacc"

#CompilationUnit# :
   (ExternAliasDirective)*
   (UsingDirective)*
   (GlobalAttributeSection)*
   (
      NamespaceDeclaration
      |
      TypeDeclaration
    )* 
   <EOF>
   {return CURRENT_NODE;}
;

ExternAliasDirective :
   "extern" "alias" <IDENTIFIER> ";"
;

UsingDirective :
    UsingStaticDirective
    |
    UsingAliasDirective
    |
    UsingNamespaceDirective
;    

UsingStaticDirective : 
    "using" "static" =>|| Name ";"
; 

UsingAliasDirective :
   "using" <IDENTIFIER> "=" =>|| Name ";"
;

UsingNamespaceDirective :
    "using" Name ";" =>||
;

GlobalAttributeSection :
   "["  ("assembly" | "module") ":" AttributeList [","] "]"
;

AttributeSection :
   "["
   [
      ("field"|"event"|"method"|"param"|"property"|"return"|"type")
      ":"
   ]
   AttributeList
   [","]
   "]"
;

AttributeList :
     Attribute ("," =>|+1 Attribute)*
;

Attribute :
   Name
   [AttributeArguments]
;

AttributeArguments :
    "(" 
    [
       SCAN ~(<IDENTIFIER>"=")
       => Expression
       (
          ","
          Expression
       )*
    ]
    [
       SCAN <IDENTIFIER>"="
       => NamedArgument
       (
          "," NamedArgument
       )*
    ]
    ")"  
;

NamedArgument :
    <IDENTIFIER> "=" Expression
;

/** Name of a Type or a Namespace */
Name :
   SCAN <IDENTIFIER> "::"
   => QualifiedAliasMember
   |
   <IDENTIFIER>[TypeArgumentList]
   ("." <IDENTIFIER> [TypeArgumentList])*
;

QualifiedAliasMember :
   <IDENTIFIER> "::" <IDENTIFIER>
   [TypeArgumentList]
;

TypeArgumentList :
   "<"
   [
      Type
      ("," Type)* 
   ]
   DEACTIVATE_TOKENS RIGHT_SHIFT, RIGHT_SHIFT_ASSIGN 
   (">")
;

NamespaceDeclaration :
   "namespace"  QualifiedIdentifier NamespaceBody [";"]
;

QualifiedIdentifier :
    <IDENTIFIER> ("." <IDENTIFIER>)*
;

NamespaceBody :
   "{"
       (ExternAliasDirective)* 
       (UsingDirective)* 
       (
          NamespaceDeclaration 
          |
          TypeDeclaration
       )*
   "}"
;

TypeDeclaration :
   ClassDeclaration
   |
   StructDeclaration
   |
   InterfaceDeclaration
   |
   EnumDeclaration
   |
   DelegateDeclaration
;

Modifiers#void : //TODO
  ("new"|"public"|"protected"|"internal"|"private"|"abstract"|"sealed"|"static"|"unsafe"|"override")*
;

ClassDeclaration :
  (AttributeSection)*
  Modifiers
  ["partial"]
  "class"
  =>||
   <IDENTIFIER>
  [TypeParameterList]
  [":" (Name | "object" | "dynamic" | "string") ("," Name)*]
  (TypeParameterConstraintsClause)*
  "{"
   (ClassMemberDeclaration)*
  "}"
  [";"]
;

StructDeclaration :
   (AttributeSection)*
   Modifiers
   ["partial"]
   "struct" 
   =>||
   <IDENTIFIER>
   [":" Name ("," Name)*]
   (TypeParameterConstraintsClause)*
   "{" (ClassMemberDeclaration)* "}"
   [";"] 
;

InterfaceDeclaration :
   (AttributeSection)*
   Modifiers
   ["partial"]
   "interface"
   =>||
   <IDENTIFIER>
   [TypeParameterList]
   [Name ("," Name)*]
   (TypeParameterConstraintsClause)*
   "{" 
   (InterfaceMemberDeclaration)* 
   "}"
   [";"]
;

InterfaceMemberDeclaration :
   InterfaceMethodDeclaration
   |
   InterfacePropertyDeclaration
   |
   InterfaceEventDeclaration
   |
   InterfaceIndexerDeclaration
; 

InterfaceEventDeclaration :
   (AttributeSection)*
   ["new"]
   "event" =>||
   Type
   <IDENTIFIER>
   ";"
;

InterfaceIndexerDeclaration :
   (AttributeSection)*
   ["new"]
   Type
   "this"
   "[" FormalParameters "]"
   "{" InterfaceAccessors "}"
;

EnumDeclaration : 
   (AttributeSection)*
   Modifiers
   "enum" 
   =>||
   <IDENTIFIER>
   [":" ("sbyte"|"byte"|"short"|"ushort"|"int"|"uint"|"long"|"ulong"|"char")]
   EnumBody
   [";"]
;

EnumBody#void :
   "{"
   [
      EnumMemberDeclaration
      ("," =>|+1 EnumMemberDeclaration)*
      [","]
   ]
   "}"
;

EnumMemberDeclaration :
   (AttributeSection)*
   <IDENTIFIER>
   ["=" Expression]
;

DelegateDeclaration :
   (AttributeSection)*
   Modifiers
  "delegate" 
  =>||
  Type
  <IDENTIFIER>
  [TypeParameterList]
  "(" [FormalParameters] ")"
  (TypeParameterConstraintsClause)*
;

TypeParameterConstraintsClause :
  "where" <IDENTIFIER> ":" (Name | "class" | "struct") ["," Name]
;

ClassMemberDeclaration :
   ConstantDeclaration
   |
   MethodDeclaration 
   | 
   FieldDeclaration 
   | 
   PropertyDeclaration 
   | 
   EventDeclaration 
   | 
   IndexerDeclaration 
   |
   OperatorDeclaration 
   | 
   ConstructorDeclaration 
   |
   SCAN ~\StructDeclaration
   => DestructorDeclaration
   |
   SCAN \StructDeclaration 
   => StructMemberDeclarationUnsafe
   |
   StaticConstructorDeclaration 
   | 
   TypeDeclaration
;

StructMemberDeclarationUnsafe :
   (AttributeSection)*
   Modifiers
   "fixed"
   Type
   (<IDENTIFIER> "[" Expression "]")+
;

ConstantDeclaration :
   (AttributeSection)*
   ("new" | "public" | "protected" | "internal" | "private")*
   "const" 
   =>||
   Type 
   ConstantDeclarator ("," ConstantDeclarator)*
   ";"
;

ConstantDeclarator : <IDENTIFIER> "=" Expression ;

FieldDeclaration :
    (AttributeSection)*
    ("new" | "public" | "protected" | "internal" | "private" | "static" | "readonly" | "volatile" | "unsafe")*
    Type
    =>|+1
    VariableDeclarator ("," VariableDeclarator)*
   ";"
;

PropertyDeclaration :
   (AttributeSection)*
   (
      "new"|"public"|"protected"|"internal"
      |"private"|"static"|"virtual"|"sealed"
      |"override"|"abstract"|"extern" | "unsafe"
   )*
   Type
   <IDENTIFIER>
   =>|+1
   PropertyBody
;

InterfacePropertyDeclaration :
   (AttributeSection)*
   ["new"]
   Type
   <IDENTIFIER>
   "{" InterfaceAccessors "}"
;

InterfaceAccessors :
    (AttributeSection)* "get" =>|| [(AttributeSection)* "set"]
    |
    (AttributeSection)* "set" =>|| [(AttributeSection)* "get"]
    | 
    FAIL "Expecting getter or setter"
;

EventDeclaration :
   (AttributeSection)*
   Modifiers
   "event"
   =>||
   Type
   (
      VariableDeclarator ("," VariableDeclarator)*
      |
      Name 
      "{" 
      (
          AddAccessorDeclaration RemoveAccessorDeclaration
          |
          RemoveAccessorDeclaration AddAccessorDeclaration
      )
      "}"
   )   
;

IndexerDeclaration :
    (AttributeSection)*
    Modifiers
    Type
    [<IDENTIFIER> "."] 
    "this"
    "["
    =>||
     FormalParameters 
    "]"
    (
       "{" AccessorDeclarations "}"
       |
       "=>" Expression ";"
    )    
;

OperatorDeclaration :
   (AttributeSection)*
   ( "public" | "static" | "extern" | "unsafe")+
   Type "operator" =>||
   (
      ("+"|"-") =>|| "(" <IDENTIFIER> ["," <IDENTIFIER>] ")"
      |
      ("!"|"~"|"++"|"--"|"true"|"false") =>|| "(" <IDENTIFIER> ")"
      |
      ("*"|"/"|"%"|"&"|"|"|"^"|"<<"|"right_shift"|"=="|"!="|">"|"<"|">="|"<=")
      "(" <IDENTIFIER> "," <IDENTIFIER> ")"
   )
;

DestructorDeclaration :
   (AttributeSection)*
   ["extern"]
   "~"
   <IDENTIFIER> 
   "(" 
   =>||
   ")"
   (Block | ";")
;

ConstructorDeclaration : 
   (AttributeSection)*
   Modifiers
   <IDENTIFIER>
   "(" =>||
   [FormalParameters]
   ")"
   [
      ":"
      ("base" | "this")
      "(" [ArgumentList] ")"
   ]
   (Block | ";")
;

StaticConstructorDeclaration :
   (AttributeSection)*
   (
      "extern" ["static"]
      |
      "static" ["extern"]
   )
   <IDENTIFIER>
   "(" =>||
   ")"
   (Block | ";")
;

ArgumentList : Argument ("," Argument)* ;

Argument :
   [=> <IDENTIFIER> ":"]
   (
      => "out" Type <IDENTIFIER> // since C# 7.0
      |
      ["ref" | "out"] Expression
   )
;

AddAccessorDeclaration :
    (AttributeSection)*
    "add"
    =>||
    Block
;

RemoveAccessorDeclaration :
    (AttributeSection)*
    "remove"
    =>||
    Block
;

AccessorDeclarations :
   GetAccessorDeclaration [SetAccessorDeclaration]
   |
   SetAccessorDeclaration [GetAccessorDeclaration]
;   

PropertyBody :
  "{" AccessorDeclarations "}"
   ["=" VariableInitializer] 
  |
  "=>" Expression ";"
;

GetAccessorDeclaration :
   (AttributeSection)*
   [
      "protected" ["internal"]
      | "internal" ["protected"]
      | "private" 
   ]
   "get" =>||
   (Block | ";")
;

SetAccessorDeclaration :
   (AttributeSection)*
   [
      "protected" ["internal"]
      | "internal" ["protected"]
      | "private" 
   ]
   "set" =>||
   (Block | ";")
;   

VariableInitializer :
   Expression
   | 
   ArrayInitializer
;

ArrayInitializer :
   "{"
      VariableInitializer [("," VariableInitializer)+ [","]]
   "}"
;

MethodDeclaration :
   (AttributeSection)*
   Modifiers
   ["partial"]
   ReturnType
   [=>Type "."] <IDENTIFIER>
   [TypeParameterList]
   "(" 
   =>||
    [FormalParameters] 
   ")"
   (TypeParameterConstraintsClause)*
   Block
;

InterfaceMethodDeclaration :
   (AttributeSection)*
   ["new"]
   ReturnType
   <IDENTIFIER>
   TypeParameterList
   "(" [FormalParameters] ")"
   (TypeParameterConstraintsClause)*
   ";"
;

ReturnType : "void" | Type ;

FormalParameters :
   ParameterArray
   |
   FixedParameter 
   (
      SCAN {getToken(1).getType() == COMMA} ~("," ParameterArray)  
      => "," FixedParameter
   )* 
   ["," ParameterArray]
;   

FixedParameter :
   (AttributeSection)*
   ("ref"| "out" | "this")*
   Type
   <IDENTIFIER>
   ["=" Expression]
;

ParameterArray : 
   (AttributeSection)*
   "params" =>|| 
   ArrayType
   <IDENTIFIER>
;

VariableDeclarator : <IDENTIFIER> ["=" Expression] ;   

TypeParameterList :
   "<"
   (AttributeSection)*
   ["in"|"out"] // Only with interfaces 
   Name
   ("," (AttributeSection)* Name)*    
   ">"
;

NonArrayType#void : Type ;

ArrayType#void : Type ;

Type :
    => "void" "*"
    |
    (
      PrimitiveType 
      |
      Name ["?"]
   )
   ( 
      SCAN 1 ~\NonArrayType =>
      "[" (",")* "]" 
   )*
   [
      SCAN 0 \ArrayType => 
      ASSERT {getToken(0).getType() == TokenType.RBRACKET}#
   ]
   ["*"]
;

PrimitiveType#void :
   "object"|"dynamic"|"string"|"decimal"|"sbyte"
   |"byte"|"short"|"ushort"|"int"|"uint"|"long"
   |"ulong"|"char"|"float"|"double"|"bool"
;

Block :
  "{"
     (Statement)* 
  "}"
;

Expression :
   AssignmentExpression
   |
   ConditionalExpression
   |
   LambdaExpression
   |
   QueryExpression
;

LambdaExpression : LambdaLHS =>|| (Block | Expression) ;

LambdaLHS :
  (
   =>ImplicitAnonymousFunctionSignature
   |
   ExplicitAnonymousFunctionSignature
  )
  "=>"
;

ImplicitAnonymousFunctionSignature :
   "(" [<IDENTIFIER> ("," <IDENTIFIER>)*] ")"
;

QueryExpression : "from" FAIL : "unimplemented" ;

AssignmentExpression :
   UnaryExpression AssignmentOperator =>|| Expression
;

MultiplicativeExpression : 
   UnaryExpression 
   (
      ("*" | "/" | "%") 
      UnaryExpression
   )*
;

AdditiveExpression :
   MultiplicativeExpression
   (
      ("+" | "-")
      MultiplicativeExpression
   )*
;

ShiftExpression :
   AdditiveExpression
   (
      ("<<" | ">>")
      AdditiveExpression
   )*
;

RelationalExpression :
   ShiftExpression
   (
      ("<"|">"|"<="|">=") ShiftExpression
      |
      "is" Type [<IDENTIFIER>]
      |
      "as" Type
   )*
;

EqualityExpression :
   RelationalExpression
   (
      ("=="|"!=") 
      RelationalExpression
   )*
;

AndExpression :
   EqualityExpression
   (
      "&"
      EqualityExpression
   )*
;

ExclusiveOrExpression :
   AndExpression
   (
      "^"
      ExclusiveOrExpression
   )*
;

InclusiveOrExpression :
   ExclusiveOrExpression 
   (
      "|"
      ExclusiveOrExpression
   )*
;

ConditionalAndExpression :
   InclusiveOrExpression
   (
      "&&"
      InclusiveOrExpression
   )*
;

ConditionalOrExpression :
    ConditionalAndExpression
    (
       "||"
       ConditionalAndExpression
    )*
;

NullCoalescingExpression :
    ConditionalOrExpression
    (
       "??"
       ConditionalOrExpression
    )*
;

ConditionalExpression : NullCoalescingExpression ["?" Expression ":" Expression] ;

AssignmentOperator #void :
  "=" 
  | "+=" 
  | "-=" 
  | "*=" 
  | "/=" 
  | "%=" 
  | "&="
  | "|="
  | "^="
  | "<<="
  | ">>="
;

UnaryExpression :
   UnaryExpressionPlusOrMinus
   |
   UnaryExpressionNotPlusMinus
   |
   CastExpression
   |
   AwaitExpression
   |
   PreIncrementExpression
   |
   PreDecrementExpression
   |
   UnaryExpressionUnsafe
   |
   NullConditionalExpression 
;

CastExpression : "(" Type ")" =>|| UnaryExpression ;

AwaitExpression : "await" UnaryExpression ;

UnaryExpressionUnsafe : ("*" | "&") UnaryExpression ;

PreIncrementExpression : "++" UnaryExpression ;

PreDecrementExpression : "--" UnaryExpression ;

UnaryExpressionPlusOrMinus : ("+" | "-") UnaryExpression ;

UnaryExpressionNotPlusMinus : ("!" | "~") UnaryExpression ;

NullConditionalOperations : 
   "?" =>|+1
   (
      "." <IDENTIFIER> [TypeArgumentList]
      |
      "[" ArgumentList "]"
   )
   (
      "." <IDENTIFIER> [TypeArgumentList]
      |
      "[" ArgumentList "]"
      |
      "(" [ArgumentList] ")"
   )*
;

NullConditionalExpression : PrimaryExpression [NullConditionalOperations] ;

PrimaryExpression :
   => ArrayCreationExpression
   |
   PrimaryNoArrayCreationExpression
;   

ArrayCreationExpression :
    "new"
    (
       RankSpecifier ArrayInitializer
       |
       NonArrayType "[" Expression ("," Expression)* "]" (RankSpecifier)* [ArrayInitializer]
       |
       ArrayType ArrayInitializer
    )
;

RankSpecifier : "[" (",")* "]" ;

PrimaryNoArrayCreationExpression :
   (
      LiteralExpression
      |
      "this"
      |
      BaseAccess
      |
      SimpleName
      |
      ParenthesizedExpression
      |
      TypeofExpression
      |
      DefaultValueExpression
      |
      NameofExpression
      |
      CheckedExpression
      |
      SizeofExpression 
      |
      UncheckedExpression
      |
      ObjectCreationExpression
      |
      AnonymousObjectCreationExpression
      |
      AnonymousMethodExpression
      |
      <INTERPOLATED_STRING_LITERAL> // TODO: deal with this better.
   )
   (
      "(" [ArgumentList] ")"
      |
      "[" Expression ("," Expression)*  "]"
      |
      "." <IDENTIFIER> [TypeArgumentList]
      |
      "->" <IDENTIFIER>
      |
      "++"
      |
      "--"
   )*   
;

BaseAccess :
   "base"
   (
     "." <IDENTIFIER>
     |
    "[" Expression ("," Expression)* "]"
   )
;

NameofExpression : "nameof" "(" NamedEntity ")" ;

NamedEntity :
   (SimpleName | "this"| "base" | PredefinedType | QualifiedAliasMember)
   ("." <IDENTIFIER> [TypeArgumentList])+
;   

PredefinedType#void :
    "bool" | "byte" | "char"| "decimal" | "double" | "float" | "int" 
    | "long" | "object" | "sbyte" | "short" | "string" | "uint" | "ulong" | "ushort"
;

DefaultValueExpression : "default" "(" =>|| Type ")" ;

SimpleName : <IDENTIFIER> [TypeArgumentList] ;

ParenthesizedExpression : "(" Expression ")" ;

TypeofExpression :
    "typeof" "("
    (
       Type
       |
       "void"
       |
       <IDENTIFIER> ["<" (",")* ">"]
    )
    ")"
;

ObjectCreationExpression :
   "new" =>|+1 [Type] // The Type is optional since C# 9
   (
      "(" [ArgumentList] ")" [ObjectInitializer | CollectionInitializer]
      |
      (ObjectInitializer | CollectionInitializer)
   )
;

AnonymousObjectCreationExpression :
   "new" 
   "{" =>||
    [MemberDeclarator ("," MemberDeclarator)* [","]]
   "}"
;

MemberDeclarator :
    <IDENTIFIER> "=" =>|| Expression
    |
    PrimaryExpression // TODO ensure that it is of the right type
;


AnonymousMethodExpression :
   "delegate"
   [
      "("
      [ExplicitAnonymousFunctionSignature]
      ")"
   ]
   Block
;

ExplicitAnonymousFunctionSignature : 
   ExplicitAnonymousFunctionParameter 
   ("," ExplicitAnonymousFunctionParameter)*
;  

ExplicitAnonymousFunctionParameter :  ["ref"|"out"] Type <IDENTIFIER> ;

ObjectInitializer :
  SCAN "{" (<IDENTIFIER> | "[" ArgumentList "]") "="
  =>
  "{" 
   MemberInitializer ("," MemberInitializer)* [","]
  "}"
;

MemberInitializer :
   (<IDENTIFIER> | "[" ArgumentList "]")
   "="
   (Expression | ObjectInitializer | CollectionInitializer)
;

CollectionInitializer : 
   "{" 
       [
          ElementInitializer ("," =>|+1 ElementInitializer)* [","]
       ]
   "}"
;

ElementInitializer :
    "{" Expression ("," Expression)* "}"
    |
    Expression // non-assignment, deal with later
;

CheckedExpression : "checked" "(" Expression ")" ;

UncheckedExpression : "unchecked" "(" Expression ")" ;

SizeofExpression : "sizeof" "(" Type ")" ;

LiteralExpression :
   "true"
   |
   "false"
   |
   "null"
   |
   <INTEGER_LITERAL>
   |
   <REAL_LITERAL>
   |
   <CHARACTER_LITERAL>
   |
   <STRING_LITERAL>
;   

Label : SCAN 2 <IDENTIFIER> ":" ;

Statement :
   (Label)*
    (
       SCAN ("const" | "var" | Type) <IDENTIFIER> =>
       DeclarationStatement
       |
       EmbeddedStatement
    )
;

EmptyStatement : ";" ;

EmbeddedStatement :
    Block 
    |
    EmptyStatement
    |
    IfStatement
    |
    WhileStatement
    |
    DoStatement
    |
    YieldStatement
    |
    CheckedStatement
    |
    UncheckedStatement
    |
    TryStatement
    |
    BreakStatement
    |
    ContinueStatement
    |
    GotoStatement
    |
    ReturnStatement
    |
    ThrowStatement
    |
    UsingStatement
    |
    LockStatement
    |
    FixedStatement
    |
    SwitchStatement
    |
    ForStatement
    |
    ForeachStatement
    |
    ExpressionStatement
;    

DeclarationStatement : 
   LocalVariableDeclaration ";"
   |
   LocalConstantDeclaration ";"
;

LocalVariableDeclaration :
   ("var" | Type) =>|+1
   LocalVariableDeclarator
   ("," LocalVariableDeclarator)*
;

LocalVariableDeclarator : <IDENTIFIER> ["=" LocalVariableInitializer] ;

LocalVariableInitializer :  
   Expression 
   | 
   ArrayInitializer 
   | 
   "stackalloc" Type "[" Expression "]"
;

LocalConstantDeclaration :
   "const"
   Type
   ConstantDeclarator
   ("," ConstantDeclarator)*
;

CheckedStatement : "checked" Block ;

UncheckedStatement : "unchecked" Block ;

BreakStatement : "break" ";" ;

ContinueStatement : "continue" ";" ;

GotoStatement : 
   "goto"
   (
      <IDENTIFIER>
      |
      "default"
      |
      "case" Expression
   )
   ";"
;   

IfStatement : "if" "(" Expression ")" EmbeddedStatement [ "else" EmbeddedStatement] ;

DoStatement : "do" EmbeddedStatement "while" "(" Expression ")" ";" ;

WhileStatement : "while" "(" Expression ")" EmbeddedStatement ;

ForeachStatement : "foreach" "(" ("var" | Type) <IDENTIFIER> "in" Expression ")" EmbeddedStatement ;

TryStatement : 
   "try" Block
   (
      FinallyClause
      |
      (CatchClause)+ [FinallyClause]
   )
;

ReturnStatement : "return" [Expression] ";" ;

ThrowStatement : "throw" [Expression] ";" ;

FinallyClause : "finally" Block ;

UnsafeStatement : "unsafe" Block ; 

CatchClause : 
   "catch" 
   [ "(" Type [<IDENTIFIER>] ")" ] 
   [ "when" "(" Expression ")" ] 
   Block
;

YieldStatement :
   "yield"
   (
      "break"
      |
      "return" Expression
   )
   ";"
;   

UsingStatement :
   "using"
   "("
   (LocalVariableDeclaration | Expression)
   ")"
   EmbeddedStatement
;

LockStatement : "lock" "(" Expression ")" EmbeddedStatement ;

FixedStatement :
   "fixed"
   "("
   FixedPointerDeclarator ("," FixedPointerDeclarator)*
   ")"
   EmbeddedStatement
;    

FixedPointerDeclarator : 
   <IDENTIFIER> 
   "=" 
   ["&"]
   Expression
;

StatementExpression :
   Expression // TODO, only certain expressions can be here!
;

ExpressionStatement : StatementExpression ";" ;

SwitchStatement : "switch" "(" Expression ")" SwitchBlock ; 

SwitchBlock : "{" (SwitchSection)* "}" ; 

SwitchLabel : 
   "case" Expression ":" 
   |
   "default" ":"
;   

SwitchSection : 
   (SwitchLabel)+ 
   (
      SCAN 0 {
         // A bit ugly. Really need to make semantic lookahead a bit more powerful 
         // in terms of negative conditions! 
                getToken(1).getType() != RBRACE
                && getToken(1).getType() != CASE 
                && !(getToken(1).getType() == DEFAULT && getToken(2).getType() == COLON)
             } 
      => Statement
   )+ 
;  

ForStatement : 
   "for" 
   "("
   [LocalVariableDeclaration | StatementExpression ("," StatementExpression)*]
   ";"
   [Expression]
   ";"
   (StatementExpression)*
   ")"
   EmbeddedStatement
;
